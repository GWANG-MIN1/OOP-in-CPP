# Chapter 1: 포인터와 참조

C++의 강력함은 메모리를 직접 제어할 수 있는 능력에서 나옵니다. 이 능력의 핵심 도구가 바로 포인터와 참조입니다. 이 두 가지 개념을 정확히 이해하는 것은 C++ 프로그래밍, 특히 객체 지향 프로그래밍의 근간을 다지는 첫걸음입니다. 이 장에서는 메모리 주소의 개념부터 시작하여 포인터와 참조의 정의, 사용법, 그리고 둘 사이의 핵심적인 차이점을 코드 중심으로 깊이 있게 탐구합니다.

## 1.1 기본 개념: 메모리와 주소

프로그램이 실행될 때, 모든 변수, 함수, 객체는 컴퓨터의 메모리 어딘가에 위치하게 됩니다. 메모리는 거대한 바이트(byte)의 배열과 같으며, 각 바이트는 고유한 번호를 가집니다. 이 고유한 번호가 바로 '메모리 주소'입니다. C++는 프로그래머가 이 메모리 주소에 직접 접근하고 조작할 수 있는 강력한 기능을 제공합니다.

### 주소 연산자 (&)

변수의 메모리 주소를 알아내기 위해 '주소 연산자(address-of operator)'인 `&`를 사용합니다. 이 연산자를 변수 이름 앞에 붙이면, 해당 변수가 저장된 메모리의 시작 주소를 반환합니다. 이 주소 값은 보통 16진수(hexadecimal)로 표현됩니다.

```cpp
#include <iostream>

int main() {
    int number = 88;
    
    // 변수의 값 출력
    std::cout << "Value of number: " << number << std::endl;
    
    // 변수의 메모리 주소 출력
    std::cout << "Address of number: " << &number << std::endl;
    
    return 0;
}

## 포인터: 주소를 저장하는 변수

포인터(pointer)는 '다른 변수의 메모리 주소'를 값으로 가지는 특별한 종류의 변수입니다. 일반 변수가 데이터 값(예: 88)을 직접 저장하는 반면, 포인터는 그 데이터가 저장된 위치(예: 0x7ffee1b4a8b4)를 저장합니다.



### 선언과 초기화
포인터는 타입 이름 뒤에 별표(*)를 붙여 선언합니다.


여기서 주의할 점은 *가 뒤따르는 변수 이름에만 적용된다는 것입니다. 예를 들어, int* p1, p2;는 포인터 p1과 일반 정수 p2를 선언하는 것입니다. 두 변수 모두 포인터로 선언하려면 int *p1, *p2;와 같이 각 변수 이름 앞에 *를 붙여야 합니다.

선언된 포인터에는 주소 연산자 &를 사용하여 다른 변수의 주소를 할당할 수 있습니다.


### 널 포인터 (nullptr)
만약 포인터가 유효한 메모리 주소를 가리키고 있지 않다면, nullptr로 초기화하는 것이 매우 중요합니다. nullptr은 포인터가 아무것도 가리키지 않음을 명시적으로 나타내는 C++11 표준 키워드입니다. 초기화되지 않은 포인터를 사용하는 것은 정의되지 않은 동작(undefined behavior)을 유발하는 심각한 버그의 원인이 되므로, 포인터는 선언과 동시에 유효한 주소나 nullptr로 초기화하는 습관을 들여야 합니다.


### 역참조 연산자 (*)
* 연산자는 선언문에서 사용될 때와 표현식에서 사용될 때의 의미가 다릅니다.

선언문에서: int* p;와 같이 변수가 포인터임을 나타냅니다.
표현식에서: *p = 99;와 같이 포인터가 가리키는 메모리 주소에 저장된 '값'에 접근합니다. 이 과정을 역참조(dereferencing) 또는 **간접 참조(indirection)**라고 합니다


## 1.3 참조: 변수의 또 다른 이름
참조(reference)는 이미 존재하는 변수에 대한 '별명(alias)'을 만드는 기능입니다. 포인터처럼 주소를 저장하기 위한 별도의 메모리 공간을 차지하는 것이 아니라, 원본 변수와 동일한 메모리 주소를 공유합니다.

### 선언과 초기화
참조는 타입 이름 뒤에 앰퍼샌드(&)를 붙여 선언하며, 두 가지 중요한 규칙을 따릅니다.

선언과 동시에 반드시 초기화해야 합니다. 초기화되지 않은 참조는 컴파일 오류를 발생시킵니다.
한 번 초기화되면 다른 변수를 참조하도록 변경할 수 없습니다. 참조는 평생 하나의 변수에 대한 별명으로 남습니다.
C++


## 1.4 핵심 차이점: 포인터 vs. 참조
포인터와 참조는 다른 변수를 간접적으로 가리킨다는 공통점이 있지만, 그 특성과 사용법에는 명확한 차이가 있습니다. 이 차이를 이해하는 것은 상황에 맞는 올바른 도구를 선택하는 데 매우 중요합니다.

## 1.5 실용적 활용과 최선의 선택
포인터와 참조의 가장 중요한 활용처는 함수에 인자를 전달할 때입니다.

값에 의한 전달 (Pass-by-Value): 기본 방식. 함수는 인자의 복사본을 받으므로 원본은 변경되지 않습니다. 하지만 객체가 크면 복사 비용이 많이 듭니다.
참조에 의한 전달 (Pass-by-Reference): 참조를 인자로 받으면 함수 내에서 원본 변수를 직접 수정할 수 있습니다. swap 함수가 대표적인 예입니다. 또한 큰 객체를 복사 없이 전달하여 성능을 향상시킬 수 있습니다.
C++

포인터에 의한 전달 (Pass-by-Pointer): 인자가 선택적일 경우(즉, nullptr을 전달하여 '없음'을 나타낼 수 있을 때) 또는 C 스타일 배열을 다룰 때 사용합니다. 포인터를 전달받는 함수는 항상 널 포인터인지 확인하는 방어적인 코드가 필요합니다.
어떤 것을 선택해야 하는가?
간단한 경험 법칙은 "가능하면 참조를 사용하고, 꼭 필요할 때만 포인터를 사용하라" 입니다.

참조를 선호하는 경우:

함수 매개변수와 반환 타입
대상이 항상 존재하고, 절대 다른 대상을 가리키도록 바꿀 필요가 없을 때
포인터를 사용해야 하는 경우:

'가리키는 대상이 없음'을 나타내는 nullptr 상태가 필요할 때
포인터 연산(예: 배열 순회)이 필요할 때
링크드 리스트, 트리 등 동적으로 할당된 노드들을 연결하는 자료구조를 구현할 때
이 장에서 다룬 포인터와 참조는 다음 장에서 배울 동적 메모리 할당과 객체 지향 프로그래밍의 여러 고급 주제를 이해하는 데 필수적인 기초 지식입니다. 이들의 의미와 차이점을 명확히 숙지하는 것이 중요합니다.