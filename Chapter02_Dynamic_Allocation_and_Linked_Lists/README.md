# Chapter 2: 동적 할당 및 링크드 리스트

이전 장에서 우리는 변수가 메모리에 어떻게 저장되고, 포인터를 통해 그 주소를 어떻게 다룰 수 있는지 배웠습니다. 하지만 지금까지 다룬 변수들은 모두 프로그램이 실행되는 도중에 필요한 만큼의 메모리를 할당하고, 원할 때 해제할 수 없었습니다. 이 질문에 대한 답이 바로 **동적 메모리 할당(Dynamic Memory Allocation)**입니다.

이 장에서는 동적 할당의 필요성과 방법을 배우고, 이를 활용한 가장 대표적인 자료구조인 링크드 리스트를 직접 구현해 봅니다.

## 2.1 왜 동적 할당이 필요한가? 스택 vs. 힙

C++ 프로그램의 메모리 공간은 크게 스택(Stack)과 힙(Heap)으로 나뉩니다.

-   **스택 (Stack):** 함수 내 지역 변수나 매개변수가 저장되는 공간입니다. 함수가 호출될 때 자동으로 메모리가 할당되고, 함수가 끝나면 자동으로 해제됩니다. 하지만 크기가 제한적이며, 변수의 크기가 **컴파일 시점(compile-time)**에 결정되어야 하는 제약이 있습니다.

-   **힙 (Heap):** 프로그램이 실행되는 동안(runtime) 필요에 따라 메모리를 할당하고 해제할 수 있는 거대한 메모리 풀입니다. '자유 저장소(free store)'라고도 불립니다. 힙을 사용하는 주된 이유는 다음과 같습니다:
    -   필요한 메모리의 크기를 컴파일 시점에 알 수 없을 때 (예: 사용자 입력에 따라 배열 크기 결정).
    -   생성된 객체가 그것을 생성한 함수의 수명을 넘어서 존재해야 할 때.

## 2.2 new와 delete: 힙 메모리 관리 도구

C++는 힙 메모리를 관리하기 위해 `new`와 `delete` 연산자를 제공합니다. 이들은 객체의 생성자와 소멸자를 호출하여 객체의 생명주기를 관리하는 핵심적인 역할을 합니다.

-   **단일 객체:** `new 타입(초기값)`으로 할당하고, `delete 포인터;`로 해제합니다.
-   **배열:** `new 타입[크기]`로 할당하고, `delete[] 포인터;`로 해제합니다. `[]`를 빠뜨리면 심각한 버그가 발생할 수 있습니다.

메모리 누수(memory leak)를 방지하려면 `new`로 할당한 모든 메모리는 반드시 `delete`로 해제해야 합니다.

## 2.3 수동 메모리 관리의 위험성

동적 메모리 할당은 유연성을 제공하지만, 프로그래머에게 큰 책임을 부여합니다.

-   **메모리 누수 (Memory Leaks):** `delete`를 잊어버리면, 할당된 메모리가 프로그램이 끝날 때까지 힙에 남아 시스템 자원을 고갈시킵니다.
-   **댕글링 포인터 (Dangling Pointers):** 이미 `delete`로 해제된 메모리를 가리키는 포인터입니다. 이 포인터를 사용하면 예측 불가능한 오류가 발생합니다. `delete` 직후 포인터를 `nullptr`로 설정하는 것이 좋은 방어책입니다.

## 2.4 실용적 응용: 링크드 리스트

동적 메모리 할당의 힘을 가장 잘 보여주는 예시가 바로 **링크드 리스트(Linked List)**입니다. 링크드 리스트는 여러 개의 **노드(Node)**가 포인터로 연결된 선형 자료구조입니다.

-   **장점:** 리스트 중간에 원소를 삽입하거나 삭제하는 연산이 매우 효율적입니다 (해당 위치를 안다면 $O(1)$).
-   **단점:** 특정 인덱스의 원소에 접근(random access)하려면 리스트의 처음부터 순차적으로 따라가야 하므로 $O(n)$의 비용이 듭니다.

각 노드는 보통 데이터와 다음 노드를 가리키는 포인터로 구성됩니다.

## 2.5 단일 링크드 리스트 구현

링크드 리스트의 상태(첫 노드를 가리키는 head 포인터 등)와 관련 연산들을 하나의 클래스로 묶어 **캡슐화(encapsulation)**하는 것이 좋은 객체 지향 설계입니다.

클래스의 소멸자(`~LinkedList()`)에서는 리스트의 모든 노드를 순회하며 `delete`를 호출하여 할당된 메모리를 모두 해제해야 합니다. 이를 통해 메모리 누수를 완벽하게 방지할 수 있습니다.

이러한 패턴, 즉 객체의 생성자에서 자원을 획득하고 소멸자에서 자원을 해제하는 방식을 **RAII (Resource Acquisition Is Initialization)** 라고 부릅니다. RAII는 C++에서 예외 안전하고 누수 없는 코드를 작성하는 가장 핵심적인 원칙입니다.