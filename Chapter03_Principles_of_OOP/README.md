# Chapter 3: 객체 지향의 원리

객체 지향 프로그래밍(Object-Oriented Programming, OOP)은 단순히 C++의 문법 기능을 사용하는 것을 넘어, 소프트웨어를 설계하고 구축하는 방식에 대한 근본적인 사고의 전환을 의미합니다. 절차적 프로그래밍이 명령어의 순차적인 목록으로 프로그램을 바라보는 반면, OOP는 현실 세계의 사물처럼 독립적인 단위, 즉 '객체'들의 상호작용으로 프로그램을 파악합니다.  각 객체는 자신만의 데이터(속성)와 그 데이터를 처리하는 기능(메서드)을 가지고 있습니다. 

이러한 접근 방식은 코드의 재사용성과 유지보수성을 획기적으로 향상시키며, 복잡한 시스템을 더 쉽게 분석하고 이해할 수 있도록 돕습니다.  이 장에서는 OOP를 지탱하는 네 가지 핵심 기둥인

**캡슐화, 상속, 다형성, 추상화**의 기본 개념을 소개합니다. 

## 3.1 캡슐화 (Encapsulation)

캡슐화는 관련된 데이터와 그 데이터를 조작하는 함수(메서드)를 하나의 '캡슐' 또는 '객체'로 묶는 것을 의미합니다.  더 나아가, 객체의 내부 상태(데이터)를 외부로부터 보호하고 숨기는 **정보 은닉(Information Hiding)**의 개념을 포함합니다. 

- **비유**: 자동차를 운전할 때 우리는 가속 페달, 브레이크, 핸들만 조작하면 됩니다. 엔진 내부의 복잡한 기계적 원리를 알 필요가 없으며, 알 수도 없습니다. 자동차 회사는 사용자가 엔진을 임의로 조작하여 차를 망가뜨리는 것을 막기 위해 엔진을 보닛 안에 '캡슐화'하고, 페달과 핸들이라는 잘 정의된 인터페이스만 외부에 공개합니다.
- **C++에서의 구현**: 클래스(class)를 통해 구현됩니다.  멤버 변수(데이터)는 주로
    
    `private`으로 선언하여 외부의 직접적인 접근을 막고, 이 변수들을 조작하는 멤버 함수(메서드)는 `public`으로 선언하여 외부와의 소통 창구 역할을 합니다.  이를 통해 객체의 데이터는 오직 허용된 메서드를 통해서만 변경될 수 있으므로, 데이터의 무결성을 보장하고 의도치 않은 수정을 방지할 수 있습니다. 
    

## 3.2 상속 (Inheritance)

상속은 기존에 존재하는 클래스(부모 클래스 또는 기본 클래스)의 속성과 기능을 물려받아 새로운 클래스(자식 클래스 또는 파생 클래스)를 만드는 메커니즘입니다. 

- **비유**: '개'와 '고양이'는 모두 '동물'의 특징을 공유합니다. '동물'이라는 부모 클래스에 '먹다', '자다'와 같은 공통 기능을 구현해두면, '개'와 '고양이' 자식 클래스는 이 기능들을 다시 만들 필요 없이 물려받을 수 있습니다. 그리고 '개'는 '짖다', '고양이'는 '야옹하다'와 같은 자신만의 고유한 기능을 추가할 수 있습니다.
- **C++에서의 구현**: `class Dog : public Animal {... };` 와 같은 문법을 사용합니다. 상속의 가장 큰 장점은 **코드 재사용성**입니다.  공통된 코드를 부모 클래스에 한번만 작성하면 되므로 중복을 줄이고, 부모 클래스의 수정이 모든 자식 클래스에 반영되어 유지보수가 용이해집니다.

## 3.3 다형성 (Polymorphism)

다형성은 그리스어로 '많은(poly) 형태(morph)'를 의미하며, 하나의 객체나 함수가 상황에 따라 여러 다른 형태나 방식으로 동작할 수 있는 능력을 말합니다. 

- **비유**: '그리기'라는 동작은 대상에 따라 다르게 수행됩니다. 원을 그리는 방식과 사각형을 그리는 방식은 다릅니다. 다형성은 '도형'이라는 하나의 인터페이스를 통해 `shape->draw()`를 호출하면, 실제 객체가 원이면 원을 그리는 메서드가, 사각형이면 사각형을 그리는 메서드가 실행되도록 하는 원리입니다.
- **C++에서의 구현**: 주로 **함수 오버라이딩(overriding)**과 **가상 함수(virtual function)**를 통해 구현됩니다. 부모 클래스의 포인터가 자식 클래스의 객체를 가리킬 수 있게 하여, 같은 함수 호출이라도 실제 객체의 타입에 따라 다른 버전의 함수가 실행되도록 합니다.  이를 통해 코드는 유연해지고, 새로운 종류의 자식 클래스가 추가되더라도 기존 코드를 수정할 필요 없이 시스템을 확장할 수 있습니다.

## 3.4 추상화 (Abstraction)

추상화는 복잡한 현실 세계의 대상을 모델링할 때, 불필요한 세부 사항은 숨기고 문제 해결에 필요한 핵심적인 특징(속성과 기능)만을 추출하여 표현하는 과정입니다. 

- **비유**: 우리가 지도를 볼 때, 실제 지형의 모든 나무, 돌, 풀을 표현하지 않습니다. 목적지를 찾는 데 필요한 도로, 건물, 강과 같은 핵심 정보만을 '추상화'하여 보여줍니다.
- **C++에서의 구현**: 클래스 정의 자체가 추상화의 한 형태입니다.  특히, **추상 클래스(abstract class)**와 **순수 가상 함수(pure virtual function)**는 추상화를 구현하는 강력한 도구입니다. 부모 클래스에서 "이 기능은 반드시 있어야 하지만, 어떻게 동작할지는 자식 클래스가 알아서 정해라"고 명시하는 인터페이스 역할을 합니다. 이를 통해 공통적인 개념을 정의하면서도 구체적인 구현은 각 자식 클래스에 위임할 수 있습니다.

이 네 가지 원리는 서로 유기적으로 연결되어 객체 지향 프로그래밍의 강력함을 만들어냅니다. 캡슐화는 객체의 독립성을 보장하고, 상속은 코드 재사용을 가능하게 하며, 다형성은 유연하고 확장 가능한 설계를 지원하고, 추상화는 복잡성을 관리하는 도구를 제공합니다. 앞으로의 장들에서 이 원리들이 C++ 코드로 어떻게 구체화되는지 자세히 살펴볼 것입니다.