# Chapter 6: 객체 지향 설계 개념

좋은 객체 지향 코드는 단순히 클래스와 객체를 사용하는 것을 넘어, 유지보수하기 쉽고, 유연하며, 확장이 용이한 소프트웨어를 만드는 것입니다. 이를 위해 수많은 개발자들이 경험을 통해 정립한 몇 가지 중요한 설계 원칙들이 있으며, 그중 가장 널리 알려진 것이 **SOLID 원칙**입니다.

SOLID는 다섯 가지 객체 지향 설계 원칙의 앞 글자를 딴 것으로, 이 원칙들을 따르면 코드의 결합도(coupling)는 낮추고 응집도(cohesion)는 높여 더 나은 설계를 할 수 있습니다.

---

## SOLID 원칙

### 1. 단일 책임 원칙 (Single Responsibility Principle, SRP)

> "클래스를 변경해야 하는 이유는 단 하나뿐이어야 한다."

하나의 클래스는 단 하나의 책임(기능)만 가져야 한다는 의미입니다. 여러 책임을 가지면 하나의 변경이 다른 기능에 영향을 미칠 수 있어 유지보수가 어려워집니다.

-   ❌ **잘못된 예:** `Order` 클래스가 주문 관리, 결제 처리, 내역 출력을 모두 담당하는 경우.
-   ✅ **좋은 예:** `Order`(주문), `PaymentProcessor`(결제), `OrderViewer`(출력) 클래스로 각각의 책임을 분리합니다.

### 2. 개방-폐쇄 원칙 (Open-Closed Principle, OCP)

> "소프트웨어 개체는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다."

새로운 기능을 추가할 때 기존 코드를 변경하는 것이 아니라, 새로운 코드를 추가함으로써(확장) 기능을 구현해야 한다는 의미입니다. 주로 추상화와 다형성을 통해 달성됩니다.

-   ❌ **잘못된 예:** 도형의 종류에 따라 `if-else` 분기문으로 넓이를 계산하는 함수. 새 도형을 추가할 때마다 함수를 수정해야 합니다.
-   ✅ **좋은 예:** `Shape` 추상 클래스의 `getArea()` 가상 함수를 각 도형 클래스(`Circle`, `Square`)가 상속받아 구현합니다. 새 도형(`Triangle`)을 추가해도 기존 코드는 수정할 필요가 없습니다.

### 3. 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)

> "자식 타입은 언제나 부모 타입으로 대체할 수 있어야 한다."

자식 클래스가 부모 클래스의 역할을 온전히 수행할 수 있어야 한다는 의미입니다. 부모 클래스 타입의 객체가 쓰이는 곳에 자식 클래스 객체를 대신 넣어도 프로그램이 문제없이 동작해야 합니다.

-   ❌ **위반 예:** 정사각형(`Square`)이 직사각형(`Rectangle`)을 상속받는 경우. 직사각형의 `setWidth()`, `setHeight()` 메서드를 사용하면 정사각형의 성질(너비와 높이가 같음)이 깨질 수 있으므로, 부모를 완전히 대체할 수 없습니다.
-   ✅ **해결:** 이 경우 상속 관계가 적절하지 않음을 의미하며, 별도의 클래스로 만들거나 다른 설계를 고려해야 합니다.

### 4. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)

> "클라이언트는 자신이 사용하지 않는 메서드에 의존해서는 안 된다."

하나의 거대한 범용 인터페이스보다는, 여러 개의 구체적인 목적을 가진 작은 인터페이스로 분리하는 것이 더 낫다는 원칙입니다.

-   ❌ **위반 예:** 프린터, 스캐너, 팩스 기능이 모두 포함된 거대한 `IMultiFunctionDevice` 인터페이스. 프린터 기능만 필요한 클래스도 쓰지도 않을 `scan()`, `fax()` 메서드를 억지로 구현해야 합니다.
-   ✅ **좋은 예:** `IPrinter`, `IScanner`, `IFax`와 같이 각 기능별로 인터페이스를 분리합니다. 클래스는 자신이 필요한 인터페이스만 선택적으로 구현하면 됩니다.

### 5. 의존성 역전 원칙 (Dependency Inversion Principle, DIP)

> "상위 수준 모듈은 하위 수준 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다."

구체적인 구현 클래스에 직접 의존하기보다는, 추상 클래스나 인터페이스 같은 **추상화**에 의존해야 한다는 의미입니다.

-   ❌ **위반 예:** `Car` 클래스가 내부에서 `SnowTire` 객체를 직접 생성하여 사용하는 경우. 타이어를 바꾸려면 `Car` 클래스의 코드를 직접 수정해야 합니다.
-   ✅ **좋은 예:** `Car` 클래스는 `Tire`라는 추상 인터페이스에만 의존합니다. 실제 사용할 타이어 객체(`SnowTire`, `SportsTire` 등)는 외부에서 생성하여 `Car`에 주입(Dependency Injection)해 줍니다. 이렇게 하면 타이어를 교체해도 `Car` 코드는 변경되지 않습니다.

---

SOLID 원칙은 처음에는 추상적이고 복잡하게 느껴질 수 있지만, 실제 프로그래밍 과정에서 꾸준히 적용하려고 노력하면 코드의 품질을 크게 향상시키고 장기적으로 더 관리하기 쉬운 소프트웨어를 만드는 데 큰 도움이 됩니다.