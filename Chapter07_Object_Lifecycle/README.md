# Chapter 7: 객체의 생성 및 소멸

객체는 생성(creation)되어 생명을 시작하고, 소멸(destruction)되면서 생을 마감합니다. C++에서는 이 생명주기를 관리하기 위해 **생성자(Constructor)**와 **소멸자(Destructor)**라는 특별한 멤버 함수를 제공합니다. 이 함수들은 객체의 초기화와 자원 정리를 자동화하여 안정적인 프로그래밍을 가능하게 합니다.

## 7.1 생성자 (Constructor)

생성자는 객체가 생성될 때 자동으로 호출되는 함수입니다. 주된 목적은 객체의 멤버 변수를 초기화하거나, 객체가 사용될 준비를 하는 데 필요한 사전 작업을 수행하는 것입니다.

**생성자의 특징:**
-   클래스의 이름과 동일한 이름을 가집니다.
-   반환 타입을 명시하지 않습니다 (void도 아님).
-   객체 생성 시 단 한 번만 호출됩니다.
-   매개변수의 종류나 개수를 다르게 하여 여러 개를 중복 정의(오버로딩)할 수 있습니다.

### 생성자의 종류

-   **기본 생성자 (Default Constructor):** 매개변수가 없는 생성자입니다. 프로그래머가 어떤 생성자도 정의하지 않으면, 컴파일러가 빈 기본 생성자를 자동으로 만들어줍니다.
-   **매개변수 있는 생성자 (Parameterized Constructor):** 객체 생성 시 외부로부터 값을 전달받아 멤버 변수를 초기화하는 생성자입니다.

```cpp
#include <iostream>
#include <string>

class Player {
private:
    std::string name;
    int level;
public:
    Player() { // 기본 생성자
        name = "Unknown";
        level = 1;
        std::cout << "기본 생성자 호출! " << name << " 생성." << std::endl;
    }
    Player(std::string pName, int pLevel) { // 매개변수 있는 생성자
        name = pName;
        level = pLevel;
        std::cout << "매개변수 생성자 호출! " << name << " 생성." << std::endl;
    }
    void showStatus() const {
        std::cout << "Name: " << name << ", Level: " << level << std::endl;
    }
};
```
## 7.2 소멸자 (Destructor)
- 소멸자는 객체가 소멸될 때 자동으로 호출되는 함수입니다. 
  주된 목적은 객체가 사용하던 자원(예: 동적 할당된 메모리)을 해제하는 것입니다.

### 소멸자의 특징:

- 클래스 이름 앞에 물결표(~)를 붙인 형태의 이름을 가집니다.
- 반환 타입이 없고, 매개변수를 가질 수 없습니다.
- 클래스당 하나만 존재할 수 있으며, 오버로딩이 불가능합니다.

## 7.3 복사 생성자 (Copy Constructor)
- 복사 생성자는 같은 클래스의 다른 객체를 인자로 받아 그 객체의 복사본으로 새로운 객체를 생성할 때 호출되는 특별한 생성자입니다.

### 호출되는 경우:

- MyClass obj2 = obj1; 또는 MyClass obj2(obj1); 형태로 객체를 초기화할 때
- 객체를 함수에 값으로 전달(pass-by-value)하거나 값으로 반환(return-by-value)할 때

### 얕은 복사 vs. 깊은 복사
- 얕은 복사 (Shallow Copy): 멤버 변수의 값을 그대로 1:1로 복사합니다. 포인터 멤버가 있다면 주소 값만 복사되어, 원본과 사본이 동일한 메모리를 공유하게 됩니다. 이는 이중 해제(double free)와 같은   심각한 문제를 유발할 수 있습니다. 컴파일러가 자동으로 만들어주는 복사 생성자는 얕은 복사를 수행합니다.
- 깊은 복사 (Deep Copy): 포인터가 가리키는 데이터 자체를 위한 새로운 메모리 공간을 할당하고, 그 내용을 복사하는 방식입니다. 포인터 멤버를 가진 클래스는 대부분 사용자가 직접 복사 생성자를 정의하여 깊은 복사를 구현해야 합니다.

## 7.4 소유권과 3/5/0의 법칙 (Rule of Three/Five/Zero)
- C++에서 수동으로 리소스를 관리하는 클래스를 작성할 때 따르는 중요한 지침입니다.
### 3의 법칙 (Rule of Three):
- 클래스가 소멸자, 복사 생성자, 복사 대입 연산자 중 하나라도 직접 정의해야 한다면, 아마도 세 가지 모두를 정의해야 합니다.
### 5의 법칙 (Rule of Five): 
- C++11부터는 3의 법칙에 더해 이동 생성자와 이동 대입 연산자까지 총 다섯 가지를 모두 고려해야 한다는 규칙입니다.
### 0의 법칙 (Rule of Zero): 
- 가장 현대적인 접근법입니다. std::vector, std::string, std::unique_ptr 같은 리소스 관리 전문 클래스를 사용하여 직접적인 리소스 관리를 피하라는 것입니다. 
 이렇게 하면 프로그래머는 5가지 특별 멤버 함수를 하나도 작성할 필요가 없어지며, 코드는 더 단순하고 안전해집니다.

