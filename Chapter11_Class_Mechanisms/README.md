# Chapter 11: C++ 클래스 메커니즘 (핵심 요약)

이 장에서는 C++ 객체의 생명주기와 자원 관리를 책임지는 생성자, 소멸자, 그리고 이와 관련된 핵심 규칙들을 알아봅니다.

---

## 1. 객체의 생명주기: 생성과 소멸

### 생성자 (Constructor)
-   **목적:** 객체가 생성될 때, 멤버 변수를 **초기화**하고 필요한 사전 작업을 수행합니다.
-   **핵심 기법 (멤버 초기화 리스트):** 생성자 본문 `{}`에서 대입하는 것보다, `MyClass() : member(value) {}` 와 같이 초기화 리스트를 사용하는 것이 더 효율적이고 표준적인 방법입니다. (`const`나 참조 멤버는 반드시 이 방법을 사용해야 합니다.)

### 소멸자 (Destructor)
-   **목적:** 객체가 소멸될 때, 객체가 사용하던 **자원을 해제**합니다. (예: `new`로 할당한 메모리를 `delete` 하기)
-   **특징:** 클래스 이름 앞에 `~`를 붙이며(`~MyClass()`), 매개변수를 가질 수 없습니다.

### 생성 및 소멸 순서 (상속 관계에서)
-   ✅ **생성 순서:** **부모 → 자식** (기초 공사부터)
-   ✅ **소멸 순서:** **자식 → 부모** (내부 철거부터, 생성의 역순)

---

## 2. 자원 관리 규칙: 3, 5, 그리고 0

클래스가 동적 메모리와 같은 자원을 직접 관리할 때 따라야 하는 중요한 규칙들입니다.

### 3의 법칙 (The Rule of Three) - 전통적인 C++
> "클래스가 **소멸자, 복사 생성자, 복사 대입 연산자** 중 하나라도 직접 정의했다면, 세 가지 모두를 정의해야 한다."

-   **이유:** 클래스가 `new`로 자원을 할당하면, `delete`를 위한 **소멸자**가 필요합니다. 이 경우, 컴파일러가 기본으로 제공하는 '얕은 복사'는 **이중 해제(double-free)** 오류를 유발하므로, '깊은 복사'를 수행하는 **복사 생성자**와 **복사 대입 연산자**를 반드시 직접 만들어야 합니다.

### 5의 법칙 (The Rule of Five) - C++11 이후
> 3의 법칙 + **이동 생성자** + **이동 대입 연산자**

-   **목적:** 불필요한 '깊은 복사'의 비용을 줄이기 위해, 임시 객체 등의 자원 소유권을 '복사'하는 대신 '훔쳐오는(이동하는)' **이동 의미론(Move Semantics)**을 지원하기 위함입니다. 이를 통해 성능을 크게 향상시킬 수 있습니다.

### 0의 법칙 (The Rule of Zero) - 현대 C++ Best Practice
> "클래스가 자원을 직접 관리하지 않도록 설계하여, 5가지 특별 멤버 함수를 하나도 정의하지 마라."

-   **방법:** 원시 포인터(`int*`)나 `new`/`delete`를 직접 사용하는 대신, 자원 관리를 전문으로 하는 클래스들을 사용합니다.
    -   **`std::vector`**, **`std::string`**
    -   **스마트 포인터 (`std::unique_ptr`, `std::shared_ptr`)**
-   **장점:** 이 스마트한 클래스들이 '5의 법칙'을 완벽하게 구현하고 있으므로, 우리는 자원 관리에 대해 전혀 신경 쓸 필요가 없습니다. 코드가 매우 **단순해지고, 안전해지며, 버그가 사라집니다.**

**결론:** C++ 프로그래밍은 직접적인 메모리 관리(3의 법칙)에서 벗어나, 현대적인 자원 관리 클래스에 위임하는 것(0의 법칙)을 강력히 권장하는 방향으로 발전했습니다.