# Chapter 13: 고급 상속 패턴

**목표:** 다중 상속을 포함한 복잡한 상속 시나리오를 마스터하고, 이들이 야기하는 문제점들과 이를 해결하기 위해 C++에 도입된 기능들을 이해합니다.

## 13.1 다중 상속: 기능의 조합

**다중 상속(Multiple Inheritance)**은 하나의 클래스가 두 개 이상의 기반 클래스로부터 동시에 상속받을 수 있게 하는 C++의 강력한 기능입니다. 예를 들어, `class AmphibiousVehicle : public Car, public Boat {};`와 같이 선언할 수 있습니다.

이 기능은 서로 다른 기능 집합을 결합할 때 유용할 수 있습니다. 예를 들어, `Camera` 클래스와 `Phone` 클래스를 다중 상속받아 `CameraPhone` 클래스를 만드는 경우를 생각해 볼 수 있습니다.

하지만 다중 상속은 **모호성(ambiguity)** 문제를 야기할 수 있습니다. 만약 `Car`와 `Boat` 클래스 모두에 `start()`라는 이름의 메서드가 있다면, `myAmphibiousVehicle.start()` 호출은 모호합니다. 컴파일러는 어느 기반 클래스의 `start()`를 호출해야 할지 알 수 없기 때문입니다. 이 경우, 프로그래머는 범위 지정 연산자(`::`)를 사용하여 `myAmphibiousVehicle.Car::start();`와 같이 호출할 함수를 명시적으로 지정해야 합니다.

## 13.2 다이아몬드 문제 (The Diamond Problem)

다이아몬드 문제는 다중 상속에서 발생하는 특수하고 치명적인 모호성 문제입니다. 이는 클래스 D가 클래스 B와 C를 상속하고, B와 C가 모두 공통의 기반 클래스 A를 상속하는 아래와 같은 다이아몬드 형태의 계층 구조에서 발생합니다.

 A (Person)
 / \
/   \
네, 알겠습니다. 다이아몬드 구조 그림을 포함하여, 챕터 13의 전체 내용을 다시 한번 깔끔하게 정리해 README.md 파일 하나로 만들어 드리겠습니다.

이전 요약본들이 너무 간결했던 것 같습니다. 아래는 처음에 제공해주신 상세한 설명을 바탕으로, 가독성 좋게 다듬은 최종 버전입니다.

Markdown

# Chapter 13: 고급 상속 패턴

**목표:** 다중 상속을 포함한 복잡한 상속 시나리오를 마스터하고, 이들이 야기하는 문제점들과 이를 해결하기 위해 C++에 도입된 기능들을 이해합니다.

## 13.1 다중 상속: 기능의 조합

**다중 상속(Multiple Inheritance)**은 하나의 클래스가 두 개 이상의 기반 클래스로부터 동시에 상속받을 수 있게 하는 C++의 강력한 기능입니다. 예를 들어, `class AmphibiousVehicle : public Car, public Boat {};`와 같이 선언할 수 있습니다.

이 기능은 서로 다른 기능 집합을 결합할 때 유용할 수 있습니다. 예를 들어, `Camera` 클래스와 `Phone` 클래스를 다중 상속받아 `CameraPhone` 클래스를 만드는 경우를 생각해 볼 수 있습니다.

하지만 다중 상속은 **모호성(ambiguity)** 문제를 야기할 수 있습니다. 만약 `Car`와 `Boat` 클래스 모두에 `start()`라는 이름의 메서드가 있다면, `myAmphibiousVehicle.start()` 호출은 모호합니다. 컴파일러는 어느 기반 클래스의 `start()`를 호출해야 할지 알 수 없기 때문입니다. 이 경우, 프로그래머는 범위 지정 연산자(`::`)를 사용하여 `myAmphibiousVehicle.Car::start();`와 같이 호출할 함수를 명시적으로 지정해야 합니다.

## 13.2 다이아몬드 문제 (The Diamond Problem)

다이아몬드 문제는 다중 상속에서 발생하는 특수하고 치명적인 모호성 문제입니다. 이는 클래스 D가 클래스 B와 C를 상속하고, B와 C가 모두 공통의 기반 클래스 A를 상속하는 아래와 같은 다이아몬드 형태의 계층 구조에서 발생합니다.

  A (Person)
 / \
/   \
B(Student) C(Faculty)
\   /
\ /
D (TeachingAssistant)

**핵심 문제:** 특별한 조치 없이는 파생 클래스 D 내에 기반 클래스 A의 하위 객체(subobject)가 **두 개** 존재하게 된다는 것입니다. 하나는 B를 통해, 다른 하나는 C를 통해 상속됩니다. 이로 인해 다음과 같은 문제들이 발생합니다.

-   **멤버 접근의 모호성:** `d.a_member`와 같이 A의 멤버에 접근하려 하면, B를 통한 멤버인지 C를 통한 멤버인지 알 수 없어 컴파일 오류가 발생합니다.
-   **상태 중복 및 메모리 낭비:** A의 멤버 변수들이 중복되어 메모리를 낭비합니다.
-   **개념적 혼란:** `TeachingAssistant`는 `Person`이라는 개념을 두 번이 아닌 한 번만 상속받는 것이 논리적으로 맞습니다.

## 13.3 가상 상속: 다이아몬드 문제 해결

**가상 상속(Virtual Inheritance)**은 다이아몬드 문제를 해결하기 위해 C++에 도입된 기법으로, 손자 클래스가 공통 기반 클래스의 멤버를 **단 하나의 복사본만** 상속받도록 보장합니다.

#### 구문
중간 단계의 클래스(`B`와 `C`)들이 상속을 `virtual`로 선언합니다.

```cpp
class Student : virtual public Person {};
class Faculty : virtual public Person {};
```