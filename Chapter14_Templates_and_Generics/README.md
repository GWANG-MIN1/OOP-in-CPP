# Chapter 14: 템플릿과 제네릭 프로그래밍 (핵심 요약)

**목표:** 코드 중복을 피하고, 어떤 데이터 타입에도 적용할 수 있는 일반적인(generic) 코드를 작성하기 위해 C++ 템플릿을 이해하고 사용하는 것입니다.

---

### 1. 함수 템플릿 (Function Templates)

-   **정의:** 다양한 데이터 타입에 대해 동작하는 하나의 '함수 틀'을 만드는 기능입니다.
-   **문법:** `template <typename T>` 를 함수 정의 앞에 붙여줍니다. `T`는 타입 매개변수입니다.
-   **핵심 특징: 타입 추론 (Type Deduction)**
    -   컴파일러가 함수에 전달된 인자(예: `5`, `10.5`)를 보고 `T`가 `int`인지 `double`인지 **자동으로 알아챕니다.**
    -   따라서 `max<int>(5, 10)` 대신 `max(5, 10)`처럼 간편하게 호출할 수 있습니다.

---

### 2. 클래스 템플릿 (Class Templates)

-   **정의:** `Stack<T>`, `vector<T>` 처럼 특정 데이터 타입에 종속되지 않는 범용 '클래스 틀'을 만드는 기능입니다.
-   **문법:** `template <typename T>` 를 클래스 정의 앞에 붙여줍니다.
-   **핵심 특징: 명시적 인스턴스화 (Explicit Instantiation)**
    -   객체를 만들 때, 사용할 타입을 **반드시 명시적으로 지정**해야 합니다.
    -   예: `Stack<int> myIntStack;`, `Stack<std::string> myStringStack;`
    -   컴파일러가 타입을 자동으로 추론할 수 없습니다.

---

### 3. 템플릿 사용의 가장 중요한 규칙: 헤더 파일

-   **문제점:** 템플릿은 그 자체로 코드가 아니라, 특정 타입이 주어졌을 때 컴파일러가 코드를 생성하는 **'설계도'**입니다. 만약 일반 클래스처럼 선언부(.h)와 구현부(.cpp)를 분리하면, 컴파일러가 설계도만 보고 코드를 만들 수 없어서 최종 단계에서 **링커 에러(Linker Error)**가 발생합니다.

-   **✅ 해결책 (표준적인 방법):**
    -   템플릿은 **선언과 구현(함수 본문)을 모두 헤더 파일(.h 또는 .hpp) 안에 작성**해야 합니다.
    -   이렇게 해야 템플릿을 사용하는 모든 곳에서 컴파일러가 전체 정의를 보고 필요한 타입의 코드를 정상적으로 생성할 수 있습니다.